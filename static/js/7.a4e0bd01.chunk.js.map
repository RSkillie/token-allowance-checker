{"version":3,"sources":["../node_modules/bnc-onboard/dist/esm/ledger-2b7bdef4.js","../../src/helpers.js","../../src/index.js","../node_modules/bnc-onboard/dist/esm/providerEngine-17e38f7e.js","../../src/TransportU2F.js","../node_modules/u2f-api/index.js","../node_modules/u2f-api/lib/u2f-api.js","../node_modules/u2f-api/lib/google-u2f-api.js","../../src/Transport.js","../../src/Eth.js","../../src/utils.js"],"names":["_slicedToArray","arr","i","Array","isArray","_arrayWithHoles","Symbol","iterator","Object","prototype","toString","call","_arr","_n","_d","_e","undefined","_s","_i","next","done","push","value","length","err","_iterableToArrayLimit","TypeError","_nonIterableRest","_toConsumableArray","arr2","_arrayWithoutHoles","iter","from","_iterableToArray","_nonIterableSpread","asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","error","Promise","then","_asyncToGenerator","fn","self","this","args","arguments","apply","ledgerProvider","_x2","_ledgerProvider","mark","_callee9","options","networkId","rpcUrl","BigNumber","networkName","basePath","addressToPath","enabled","provider","enable","addresses","getPrimaryAddress","getAllAccountsAndBalances","_getAllAccountsAndBalances","setPrimaryAccount","_getAccounts","getBalance","_signTransaction","_signTransaction2","wrap","_context9","prev","_callee8","transactionData","path","transport","eth","transaction","ledgerResult","_context8","values","TransportU2F","create","sent","Eth","t0","Error","Transaction","chain","raw","buffer","Buffer","signTransaction","serialize","v","r","s","abrupt","concat","t1","close","finish","stop","_x5","address","sendAsync","jsonrpc","method","params","id","e","res","result","numberToGet","getMore","_ref3","_callee5","addressesAlreadyFetched","paths","ledgerLive","legacy","_i2","_paths","_ref4","allAddresses","_context5","size","message","getAddress","set","toLowerCase","_x3","_x4","accounts","entries","accountIndex","findIndex","_ref","unshift","splice","Map","_callee7","amountToGet","_args7","_context7","all","map","_ref5","_callee6","balance","_context6","_x6","keys","networkIdToDerivationPath","createProvider","getAccounts","callback","send","ledger","preferred","label","iconSrc","name","svg","wallet","_wallet","_callee4","helpers","_context4","connect","disconnect","get","_get","_callee","_context","network","_get2","_callee2","_context2","_get3","_callee3","_context3","_x","type","desktop","errorClasses","deserializers","addCustomErrorDeserializer","createCustomErrorClass","C","EthAppPleaseEnableContractData","TransportRaceCondition","TransportError","StatusCodes","PIN_REMAINING_ATTEMPTS","INCORRECT_LENGTH","COMMAND_INCOMPATIBLE_FILE_STRUCTURE","SECURITY_STATUS_NOT_SATISFIED","CONDITIONS_OF_USE_NOT_SATISFIED","INCORRECT_DATA","NOT_ENOUGH_MEMORY_SPACE","REFERENCED_DATA_NOT_FOUND","FILE_ALREADY_EXISTS","INCORRECT_P1_P2","INS_NOT_SUPPORTED","CLA_NOT_SUPPORTED","TECHNICAL_PROBLEM","OK","MEMORY_PROBLEM","NO_EF_SELECTED","INVALID_OFFSET","FILE_NOT_FOUND","INCONSISTENT_FILE","ALGORITHM_NOT_SUPPORTED","INVALID_KCV","CODE_NOT_INITIALIZED","ACCESS_CONDITION_NOT_FULFILLED","CONTRADICTION_SECRET_CODE_STATUS","CONTRADICTION_INVALIDATION","CODE_BLOCKED","MAX_VALUE_REACHED","GP_AUTH_FAILED","LICENSING","HALTED","statusText","k","smsg","code","getAltStatusMessage","statusCodeStr","statusCode","TransportStatusError","config","idMgmt","HookedWalletSubprovider","rpcSubProvider","RpcSource","includes","Web3ProviderEngine","addProvider","SubscriptionSubprovider","FilterSubprovider","start","wrapU2FTransportError","originalError","webSafe64","base64","attemptExchange","keyHandle","apdu","wrapApdu","challenge","signRequest","version","appId","location","origin","log","timeoutMillis","response","signatureData","data","substring","transportInstances","constructor","scrambleKey","unwrap","u2fError","t","isSupported","list","supported","listen","observer","unsubscribed","descriptor","unsubscribe","module","exports","require","API","chromeApi","isBrowser","navigator","userAgent","isSafari","match","isEDGE","_backend","getBackend","notSupported","u2f","native","window","sign","protocol","MessageChannel","ok","bind","ensureSupport","register","ErrorCodes","ErrorNames","makeError","msg","errorCode","metaData","deferPromise","promise","ret","cancel","backend","_ensureSupport","registerRequests","signRequests","timeout","makeDefault","func","global","slice","CANCELLED","OTHER_ERROR","BAD_REQUEST","CONFIGURATION_UNSUPPORTED","DEVICE_INELIGIBLE","TIMEOUT","EXTENSION_ID","MessageTypes","Request","Response","SignRequest","SignResponse","RegisterRequest","RegisterResponse","port_","getMessagePort","chrome","runtime","U2F_SIGN_REQUEST","sendMessage","lastError","getIframePort_","getChromeRuntimePort_","port","setTimeout","WrappedChromeRuntimePort_","postMessage","addEventListener","eventName","handler","onMessage","addListener","console","iframeOrigin","iframe","document","createElement","src","setAttribute","body","appendChild","hasCalledBack","channel","port1","ready","removeEventListener","contentWindow","port2","EXTENSION_TIMEOUT_SEC","waitingForPort_","reqCounter_","callbackMap_","getPortSingleton_","responseHandler_","shift","reqId","cb","opt_timeoutSeconds","req","timeoutSeconds","requestId","U2F_REGISTER_REQUEST","a","statusList","cla","ins","p1","sw","busyPromise","resolveBusy","unresponsiveReached","f","clearTimeout","decorateAppAPIMethod","_appAPIlock","openTimeout","found","sub","complete","listenTimeoutId","listenTimeout","Transport","open","ErrorMessage_ListenTimeout","ErrorMessage_NoDeviceFound","subscribers","obj","String","date","Date","dispatch","splitPath","boolDisplay","boolChaincode","publicKeyLength","addressLength","offset","rawTx","toSend","maxChunkSize","chunkSize","apduResponse","remapTransactionRelatedErrors","components","element","number","parseInt","isNaN","foreach","index","array","iterate"],"mappings":"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","file":"static/js/7.a4e0bd01.chunk.js","sourcesContent":["function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport 'web3-provider-engine';\nimport 'web3-provider-engine/subproviders/rpc';\nimport 'web3-provider-engine/subproviders/hooked-wallet';\nimport 'web3-provider-engine/subproviders/subscriptions';\nimport 'web3-provider-engine/subproviders/filters';\nimport { c as createProvider } from './providerEngine-17e38f7e.js';\nimport { Transaction } from 'ethereumjs-tx';\nimport TransportU2F from '@ledgerhq/hw-transport-u2f';\nimport Eth from '@ledgerhq/hw-app-eth';\nimport buffer from 'buffer';\nvar ledgerIcon = \"\\n\\t<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 450 450\\\" width=\\\"37\\\" height=\\\"37\\\"><style>.st0{fill:currentColor}</style><g id=\\\"squares_1_\\\"><path class=\\\"st0\\\" d=\\\"M578.2 392.7V24.3h25.6v344.1h175.3v24.3H578.2zm327.5 5.1c-39.7 0-70.4-12.8-93.4-37.1-21.7-24.3-33.3-58.8-33.3-103.6 0-43.5 10.2-79.3 32-104.9 21.7-26.9 49.9-39.7 87-39.7 32 0 57.6 11.5 76.8 33.3 19.2 23 28.1 53.7 28.1 92.1v20.5H804.6c0 37.1 9 66.5 26.9 85.7 16.6 20.5 42.2 29.4 74.2 29.4 15.3 0 29.4-1.3 40.9-3.8 11.5-2.6 26.9-6.4 44.8-14.1v24.3c-15.3 6.4-29.4 11.5-42.2 14.1-14.3 2.6-28.9 3.9-43.5 3.8zM898 135.6c-26.9 0-47.3 9-64 25.6-15.3 17.9-25.6 42.2-28.1 75.5h168.9c0-32-6.4-56.3-20.5-74.2-12.8-18-32-26.9-56.3-26.9zm238-21.8c19.2 0 37.1 3.8 51.2 10.2 14.1 7.7 26.9 19.2 38.4 37.1h1.3c-1.3-21.7-1.3-42.2-1.3-62.7V0h24.3v392.7h-16.6l-6.4-42.2c-20.5 30.7-51.2 47.3-89.6 47.3s-66.5-11.5-87-35.8c-20.5-23-29.4-57.6-29.4-102.3 0-47.3 10.2-83.2 29.4-108.7 19.2-25.6 48.6-37.2 85.7-37.2zm0 21.8c-29.4 0-52.4 10.2-67.8 32-15.3 20.5-23 51.2-23 92.1 0 78 30.7 116.4 90.8 116.4 30.7 0 53.7-9 67.8-26.9 14.1-17.9 21.7-47.3 21.7-89.6v-3.8c0-42.2-7.7-72.9-21.7-90.8-12.8-20.5-35.8-29.4-67.8-29.4zm379.9-16.6v17.9l-56.3 3.8c15.3 19.2 23 39.7 23 61.4 0 26.9-9 47.3-26.9 64-17.9 16.6-40.9 24.3-70.4 24.3-12.8 0-21.7 0-25.6-1.3-10.2 5.1-17.9 11.5-23 17.9-5.1 7.7-7.7 14.1-7.7 23s3.8 15.3 10.2 19.2c6.4 3.8 17.9 6.4 33.3 6.4h47.3c29.4 0 52.4 6.4 67.8 17.9s24.3 29.4 24.3 53.7c0 29.4-11.5 51.2-34.5 66.5-23 15.3-56.3 23-99.8 23-34.5 0-61.4-6.4-80.6-20.5-19.2-12.8-28.1-32-28.1-55 0-19.2 6.4-34.5 17.9-47.3s28.1-20.5 47.3-25.6c-7.7-3.8-15.3-9-19.2-15.3-5-6.2-7.7-13.8-7.7-21.7 0-17.9 11.5-34.5 34.5-48.6-15.3-6.4-28.1-16.6-37.1-30.7-9-14.1-12.8-30.7-12.8-48.6 0-26.9 9-49.9 25.6-66.5 17.9-16.6 40.9-24.3 70.4-24.3 17.9 0 32 1.3 42.2 5.1h85.7v1.3h.2zm-222.6 319.8c0 37.1 28.1 56.3 84.4 56.3 71.6 0 107.5-23 107.5-69.1 0-16.6-5.1-28.1-16.6-35.8-11.5-7.7-29.4-11.5-55-11.5h-44.8c-49.9 1.2-75.5 20.4-75.5 60.1zm21.8-235.4c0 21.7 6.4 37.1 19.2 49.9 12.8 11.5 29.4 17.9 51.2 17.9 23 0 40.9-6.4 52.4-17.9 12.8-11.5 17.9-28.1 17.9-49.9 0-23-6.4-40.9-19.2-52.4-12.8-11.5-29.4-17.9-52.4-17.9-21.7 0-39.7 6.4-51.2 19.2-12.8 11.4-17.9 29.3-17.9 51.1z\\\"/><path class=\\\"st0\\\" d=\\\"M1640 397.8c-39.7 0-70.4-12.8-93.4-37.1-21.7-24.3-33.3-58.8-33.3-103.6 0-43.5 10.2-79.3 32-104.9 21.7-26.9 49.9-39.7 87-39.7 32 0 57.6 11.5 76.8 33.3 19.2 23 28.1 53.7 28.1 92.1v20.5h-197c0 37.1 9 66.5 26.9 85.7 16.6 20.5 42.2 29.4 74.2 29.4 15.3 0 29.4-1.3 40.9-3.8 11.5-2.6 26.9-6.4 44.8-14.1v24.3c-15.3 6.4-29.4 11.5-42.2 14.1-14.1 2.6-28.2 3.8-44.8 3.8zm-6.4-262.2c-26.9 0-47.3 9-64 25.6-15.3 17.9-25.6 42.2-28.1 75.5h168.9c0-32-6.4-56.3-20.5-74.2-12.8-18-32-26.9-56.3-26.9zm245.6-21.8c11.5 0 24.3 1.3 37.1 3.8l-5.1 24.3c-11.8-2.6-23.8-3.9-35.8-3.8-23 0-42.2 10.2-57.6 29.4-15.3 20.5-23 44.8-23 75.5v149.7h-25.6V119h21.7l2.6 49.9h1.3c11.5-20.5 23-34.5 35.8-42.2 15.4-9 30.7-12.9 48.6-12.9zM333.9 12.8h-183v245.6h245.6V76.7c.1-34.5-28.1-63.9-62.6-63.9zm-239.2 0H64c-34.5 0-64 28.1-64 64v30.7h94.7V12.8zM0 165h94.7v94.7H0V165zm301.9 245.6h30.7c34.5 0 64-28.1 64-64V316h-94.7v94.6zm-151-94.6h94.7v94.7h-94.7V316zM0 316v30.7c0 34.5 28.1 64 64 64h30.7V316H0z\\\"/></g></svg>\\n\";\n\nfunction ledger(options) {\n  var rpcUrl = options.rpcUrl,\n      networkId = options.networkId,\n      preferred = options.preferred,\n      label = options.label,\n      iconSrc = options.iconSrc,\n      svg = options.svg;\n  return {\n    name: label || 'Ledger',\n    svg: svg || ledgerIcon,\n    iconSrc: iconSrc,\n    wallet: function () {\n      var _wallet = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee4(helpers) {\n        var BigNumber, networkName, provider;\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                BigNumber = helpers.BigNumber, networkName = helpers.networkName;\n                _context4.next = 3;\n                return ledgerProvider({\n                  rpcUrl: rpcUrl,\n                  networkId: networkId,\n                  BigNumber: BigNumber,\n                  networkName: networkName\n                });\n\n              case 3:\n                provider = _context4.sent;\n                return _context4.abrupt(\"return\", {\n                  provider: provider,\n                  \"interface\": {\n                    name: 'Ledger',\n                    connect: provider.enable,\n                    disconnect: function disconnect() {\n                      return provider.stop();\n                    },\n                    address: {\n                      get: function () {\n                        var _get = _asyncToGenerator(\n                        /*#__PURE__*/\n                        regeneratorRuntime.mark(function _callee() {\n                          return regeneratorRuntime.wrap(function _callee$(_context) {\n                            while (1) {\n                              switch (_context.prev = _context.next) {\n                                case 0:\n                                  return _context.abrupt(\"return\", provider.getPrimaryAddress());\n\n                                case 1:\n                                case \"end\":\n                                  return _context.stop();\n                              }\n                            }\n                          }, _callee);\n                        }));\n\n                        function get() {\n                          return _get.apply(this, arguments);\n                        }\n\n                        return get;\n                      }()\n                    },\n                    network: {\n                      get: function () {\n                        var _get2 = _asyncToGenerator(\n                        /*#__PURE__*/\n                        regeneratorRuntime.mark(function _callee2() {\n                          return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                            while (1) {\n                              switch (_context2.prev = _context2.next) {\n                                case 0:\n                                  return _context2.abrupt(\"return\", networkId);\n\n                                case 1:\n                                case \"end\":\n                                  return _context2.stop();\n                              }\n                            }\n                          }, _callee2);\n                        }));\n\n                        function get() {\n                          return _get2.apply(this, arguments);\n                        }\n\n                        return get;\n                      }()\n                    },\n                    balance: {\n                      get: function () {\n                        var _get3 = _asyncToGenerator(\n                        /*#__PURE__*/\n                        regeneratorRuntime.mark(function _callee3() {\n                          var address;\n                          return regeneratorRuntime.wrap(function _callee3$(_context3) {\n                            while (1) {\n                              switch (_context3.prev = _context3.next) {\n                                case 0:\n                                  address = provider.getPrimaryAddress();\n                                  return _context3.abrupt(\"return\", address && provider.getBalance(address));\n\n                                case 2:\n                                case \"end\":\n                                  return _context3.stop();\n                              }\n                            }\n                          }, _callee3);\n                        }));\n\n                        function get() {\n                          return _get3.apply(this, arguments);\n                        }\n\n                        return get;\n                      }()\n                    }\n                  }\n                });\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function wallet(_x) {\n        return _wallet.apply(this, arguments);\n      }\n\n      return wallet;\n    }(),\n    type: 'hardware',\n    desktop: true,\n    preferred: preferred\n  };\n}\n\nfunction ledgerProvider(_x2) {\n  return _ledgerProvider.apply(this, arguments);\n}\n\nfunction _ledgerProvider() {\n  _ledgerProvider = _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee9(options) {\n    var networkId, rpcUrl, BigNumber, networkName, basePath, addressToPath, enabled, provider, enable, addresses, getPrimaryAddress, getAllAccountsAndBalances, _getAllAccountsAndBalances, setPrimaryAccount, _getAccounts, getBalance, _signTransaction, _signTransaction2;\n\n    return regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            _signTransaction2 = function _ref15() {\n              _signTransaction2 = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee8(transactionData) {\n                var path, transport, eth, transaction, ledgerResult;\n                return regeneratorRuntime.wrap(function _callee8$(_context8) {\n                  while (1) {\n                    switch (_context8.prev = _context8.next) {\n                      case 0:\n                        path = _toConsumableArray(addressToPath.values())[0];\n                        _context8.prev = 1;\n                        _context8.next = 4;\n                        return TransportU2F.create();\n\n                      case 4:\n                        transport = _context8.sent;\n                        eth = new Eth(transport);\n                        _context8.next = 11;\n                        break;\n\n                      case 8:\n                        _context8.prev = 8;\n                        _context8.t0 = _context8[\"catch\"](1);\n                        throw new Error('Error connecting to Ledger wallet');\n\n                      case 11:\n                        _context8.prev = 11;\n                        transaction = new Transaction(transactionData, {\n                          chain: networkName(networkId)\n                        });\n                        transaction.raw[6] = buffer.Buffer.from([networkId]); // v\n\n                        transaction.raw[7] = buffer.Buffer.from([]); // r\n\n                        transaction.raw[8] = buffer.Buffer.from([]); // s\n\n                        _context8.next = 18;\n                        return eth.signTransaction(path, transaction.serialize().toString('hex'));\n\n                      case 18:\n                        ledgerResult = _context8.sent;\n                        transaction.v = buffer.Buffer.from(ledgerResult.v, 'hex');\n                        transaction.r = buffer.Buffer.from(ledgerResult.r, 'hex');\n                        transaction.s = buffer.Buffer.from(ledgerResult.s, 'hex');\n                        return _context8.abrupt(\"return\", \"0x\".concat(transaction.serialize().toString('hex')));\n\n                      case 25:\n                        _context8.prev = 25;\n                        _context8.t1 = _context8[\"catch\"](11);\n                        throw _context8.t1;\n\n                      case 28:\n                        _context8.prev = 28;\n                        transport.close();\n                        return _context8.finish(28);\n\n                      case 31:\n                      case \"end\":\n                        return _context8.stop();\n                    }\n                  }\n                }, _callee8, null, [[1, 8], [11, 25, 28, 31]]);\n              }));\n              return _signTransaction2.apply(this, arguments);\n            };\n\n            _signTransaction = function _ref14(_x5) {\n              return _signTransaction2.apply(this, arguments);\n            };\n\n            getBalance = function _ref13(address) {\n              return new Promise(function (resolve, reject) {\n                provider.sendAsync({\n                  jsonrpc: '2.0',\n                  method: 'eth_getBalance',\n                  params: [address, 'latest'],\n                  id: 42\n                }, function (e, res) {\n                  e && reject(e);\n                  var result = res && res.result;\n\n                  if (result != null) {\n                    resolve(new BigNumber(result).toString(10));\n                  } else {\n                    resolve(null);\n                  }\n                });\n              });\n            };\n\n            _getAccounts = function _ref12() {\n              var numberToGet = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n              var getMore = arguments.length > 1 ? arguments[1] : undefined;\n              return new Promise(\n              /*#__PURE__*/\n              function () {\n                var _ref3 = _asyncToGenerator(\n                /*#__PURE__*/\n                regeneratorRuntime.mark(function _callee5(resolve, reject) {\n                  var addressesAlreadyFetched, paths, i, ledgerLive, legacy, transport, eth, _i2, _paths, path, _ref4, address, allAddresses;\n\n                  return regeneratorRuntime.wrap(function _callee5$(_context5) {\n                    while (1) {\n                      switch (_context5.prev = _context5.next) {\n                        case 0:\n                          if (!enabled) {\n                            resolve([null]);\n                          }\n\n                          addressesAlreadyFetched = addressToPath.size;\n\n                          if (!(addressesAlreadyFetched > 0 && !getMore)) {\n                            _context5.next = 4;\n                            break;\n                          }\n\n                          return _context5.abrupt(\"return\", resolve(addresses()));\n\n                        case 4:\n                          paths = [];\n\n                          if (numberToGet > 1) {\n                            for (i = addressesAlreadyFetched; i < numberToGet + addressesAlreadyFetched; i++) {\n                              ledgerLive = \"\".concat(basePath, \"/\").concat(i, \"'/0/0\");\n                              legacy = \"\".concat(basePath, \"/0'/\").concat(i, \"'\");\n                              paths.push(ledgerLive, legacy);\n                            }\n                          } else {\n                            paths.push(\"\".concat(basePath, \"/0'/0\"), \"\".concat(basePath, \"/0'/0/0\"));\n                          }\n\n                          _context5.prev = 6;\n                          _context5.next = 9;\n                          return TransportU2F.create();\n\n                        case 9:\n                          transport = _context5.sent;\n                          eth = new Eth(transport);\n                          _context5.next = 16;\n                          break;\n\n                        case 13:\n                          _context5.prev = 13;\n                          _context5.t0 = _context5[\"catch\"](6);\n                          reject({\n                            message: 'Error connecting to Ledger wallet'\n                          });\n\n                        case 16:\n                          _i2 = 0, _paths = paths;\n\n                        case 17:\n                          if (!(_i2 < _paths.length)) {\n                            _context5.next = 33;\n                            break;\n                          }\n\n                          path = _paths[_i2];\n                          _context5.prev = 19;\n                          _context5.next = 22;\n                          return eth.getAddress(path);\n\n                        case 22:\n                          _ref4 = _context5.sent;\n                          address = _ref4.address;\n                          addressToPath.set(address.toLowerCase(), path);\n                          _context5.next = 30;\n                          break;\n\n                        case 27:\n                          _context5.prev = 27;\n                          _context5.t1 = _context5[\"catch\"](19);\n                          return _context5.abrupt(\"return\", reject({\n                            message: 'There was a problem trying to connect to your Ledger.'\n                          }));\n\n                        case 30:\n                          _i2++;\n                          _context5.next = 17;\n                          break;\n\n                        case 33:\n                          allAddresses = addresses();\n                          transport.close();\n                          resolve(allAddresses);\n\n                        case 36:\n                        case \"end\":\n                          return _context5.stop();\n                      }\n                    }\n                  }, _callee5, null, [[6, 13], [19, 27]]);\n                }));\n\n                return function (_x3, _x4) {\n                  return _ref3.apply(this, arguments);\n                };\n              }());\n            };\n\n            setPrimaryAccount = function _ref11(address) {\n              // make a copy and put in an array\n              var accounts = _toConsumableArray(addressToPath.entries());\n\n              var accountIndex = accounts.findIndex(function (_ref) {\n                var _ref2 = _slicedToArray(_ref, 1),\n                    accountAddress = _ref2[0];\n\n                return accountAddress === address;\n              }); // pull the item at the account index out of the array and place at the front\n\n              accounts.unshift(accounts.splice(accountIndex, 1)[0]); // reassign addressToPath to new ordered accounts\n\n              addressToPath = new Map(accounts);\n            };\n\n            _getAllAccountsAndBalances = function _ref10() {\n              _getAllAccountsAndBalances = _asyncToGenerator(\n              /*#__PURE__*/\n              regeneratorRuntime.mark(function _callee7() {\n                var amountToGet,\n                    accounts,\n                    _args7 = arguments;\n                return regeneratorRuntime.wrap(function _callee7$(_context7) {\n                  while (1) {\n                    switch (_context7.prev = _context7.next) {\n                      case 0:\n                        amountToGet = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : 5;\n                        _context7.next = 3;\n                        return _getAccounts(amountToGet, true);\n\n                      case 3:\n                        accounts = _context7.sent;\n                        return _context7.abrupt(\"return\", Promise.all(accounts.map(function (address) {\n                          return new Promise(\n                          /*#__PURE__*/\n                          function () {\n                            var _ref5 = _asyncToGenerator(\n                            /*#__PURE__*/\n                            regeneratorRuntime.mark(function _callee6(resolve) {\n                              var balance;\n                              return regeneratorRuntime.wrap(function _callee6$(_context6) {\n                                while (1) {\n                                  switch (_context6.prev = _context6.next) {\n                                    case 0:\n                                      _context6.next = 2;\n                                      return getBalance(address);\n\n                                    case 2:\n                                      balance = _context6.sent;\n                                      resolve({\n                                        address: address,\n                                        balance: balance\n                                      });\n\n                                    case 4:\n                                    case \"end\":\n                                      return _context6.stop();\n                                  }\n                                }\n                              }, _callee6);\n                            }));\n\n                            return function (_x6) {\n                              return _ref5.apply(this, arguments);\n                            };\n                          }());\n                        })));\n\n                      case 5:\n                      case \"end\":\n                        return _context7.stop();\n                    }\n                  }\n                }, _callee7);\n              }));\n              return _getAllAccountsAndBalances.apply(this, arguments);\n            };\n\n            getAllAccountsAndBalances = function _ref9() {\n              return _getAllAccountsAndBalances.apply(this, arguments);\n            };\n\n            getPrimaryAddress = function _ref8() {\n              return enabled ? addresses()[0] : undefined;\n            };\n\n            addresses = function _ref7() {\n              return Array.from(addressToPath.keys());\n            };\n\n            enable = function _ref6() {\n              enabled = true;\n              return _getAccounts(1);\n            };\n\n            networkId = options.networkId, rpcUrl = options.rpcUrl, BigNumber = options.BigNumber, networkName = options.networkName;\n            basePath = networkIdToDerivationPath(networkId);\n            addressToPath = new Map();\n            enabled = false;\n            provider = createProvider({\n              getAccounts: function getAccounts(callback) {\n                _getAccounts().then(function (res) {\n                  return callback(null, res);\n                })[\"catch\"](function (err) {\n                  return callback(err, null);\n                });\n              },\n              signTransaction: function signTransaction(transactionData, callback) {\n                _signTransaction(transactionData).then(function (res) {\n                  return callback(null, res);\n                })[\"catch\"](function (err) {\n                  return callback(err, null);\n                });\n              },\n              rpcUrl: rpcUrl\n            });\n            provider.getPrimaryAddress = getPrimaryAddress;\n            provider.getAllAccountsAndBalances = getAllAccountsAndBalances;\n            provider.enable = enable;\n            provider.setPrimaryAccount = setPrimaryAccount;\n            provider.getBalance = getBalance;\n            provider.send = provider.sendAsync;\n            return _context9.abrupt(\"return\", provider);\n\n          case 22:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n  return _ledgerProvider.apply(this, arguments);\n}\n\nfunction networkIdToDerivationPath(networkId) {\n  switch (networkId) {\n    default:\n      return \"m/44'/60'\";\n  }\n}\n\nexport default ledger;","// @flow\n/* eslint-disable no-continue */\n/* eslint-disable no-param-reassign */\n/* eslint-disable no-prototype-builtins */\n\nconst errorClasses = {};\nconst deserializers = {};\n\nexport const addCustomErrorDeserializer = (\n  name: string,\n  deserializer: Object => *\n) => {\n  deserializers[name] = deserializer;\n};\n\nexport const createCustomErrorClass = (name: string): Class<any> => {\n  const C = function CustomError(message?: string, fields?: Object) {\n    Object.assign(this, fields);\n    this.name = name;\n    this.message = message || name;\n    this.stack = new Error().stack;\n  };\n  // $FlowFixMe\n  C.prototype = new Error();\n\n  errorClasses[name] = C;\n  // $FlowFixMe we can't easily type a subset of Error for now...\n  return C;\n};\n\n// inspired from https://github.com/programble/errio/blob/master/index.js\nexport const deserializeError = (object: mixed): Error => {\n  if (typeof object === \"object\" && object) {\n    try {\n      // $FlowFixMe FIXME HACK\n      const msg = JSON.parse(object.message);\n      if (msg.message && msg.name) {\n        object = msg;\n      }\n    } catch (e) {\n      // nothing\n    }\n\n    let error;\n    if (typeof object.name === \"string\") {\n      const { name } = object;\n      const des = deserializers[name];\n      if (des) {\n        error = des(object);\n      } else {\n        let constructor = name === \"Error\" ? Error : errorClasses[name];\n\n        if (!constructor) {\n          console.warn(\"deserializing an unknown class '\" + name + \"'\");\n          constructor = createCustomErrorClass(name);\n        }\n\n        error = Object.create(constructor.prototype);\n        try {\n          for (const prop in object) {\n            if (object.hasOwnProperty(prop)) {\n              error[prop] = object[prop];\n            }\n          }\n        } catch (e) {\n          // sometimes setting a property can fail (e.g. .name)\n        }\n      }\n    } else {\n      error = new Error(object.message);\n    }\n\n    if (!error.stack && Error.captureStackTrace) {\n      Error.captureStackTrace(error, deserializeError);\n    }\n    return error;\n  }\n  return new Error(String(object));\n};\n\n// inspired from https://github.com/sindresorhus/serialize-error/blob/master/index.js\nexport const serializeError = (value: mixed) => {\n  if (!value) return value;\n  if (typeof value === \"object\") {\n    return destroyCircular(value, []);\n  }\n  if (typeof value === \"function\") {\n    return `[Function: ${value.name || \"anonymous\"}]`;\n  }\n  return value;\n};\n\n// https://www.npmjs.com/package/destroy-circular\nfunction destroyCircular(from: Object, seen) {\n  const to = {};\n  seen.push(from);\n  for (const key of Object.keys(from)) {\n    const value = from[key];\n    if (typeof value === \"function\") {\n      continue;\n    }\n    if (!value || typeof value !== \"object\") {\n      to[key] = value;\n      continue;\n    }\n    if (seen.indexOf(from[key]) === -1) {\n      to[key] = destroyCircular(from[key], seen.slice(0));\n      continue;\n    }\n    to[key] = \"[Circular]\";\n  }\n  if (typeof from.name === \"string\") {\n    to.name = from.name;\n  }\n  if (typeof from.message === \"string\") {\n    to.message = from.message;\n  }\n  if (typeof from.stack === \"string\") {\n    to.stack = from.stack;\n  }\n  return to;\n}\n","// @flow\n\n/**\n * A Log object\n */\nexport type Log = {\n  type: string,\n  message?: string,\n  data?: any,\n  id: string, // unique amount all logs\n  date: Date // date of the log\n};\n\nexport type Unsubscribe = () => void;\n\nlet id = 0;\nconst subscribers = [];\n\n/**\n * log something\n * @param type a namespaced identifier of the log (it is not a level like \"debug\", \"error\" but more like \"apdu-in\", \"apdu-out\", etc...)\n * @param message a clear message of the log associated to the type\n */\nexport const log = (type: string, message?: string, data?: any) => {\n  const obj: Log = { type, id: String(++id), date: new Date() };\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  dispatch(obj);\n};\n\n/**\n * listen to logs.\n * @param cb that is called for each future log() with the Log object\n * @return a function that can be called to unsubscribe the listener\n */\nexport const listen = (cb: Log => void): Unsubscribe => {\n  subscribers.push(cb);\n  return () => {\n    const i = subscribers.indexOf(cb);\n    if (i !== -1) {\n      // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952\n      subscribers[i] = subscribers[subscribers.length - 1];\n      subscribers.pop();\n    }\n  };\n};\n\nfunction dispatch(log: Log) {\n  for (let i = 0; i < subscribers.length; i++) {\n    try {\n      subscribers[i](log);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n\n// for debug purpose\nglobal.__ledgerLogsListen = listen;\n","import Web3ProviderEngine from 'web3-provider-engine';\nimport RpcSource from 'web3-provider-engine/subproviders/rpc';\nimport HookedWalletSubprovider from 'web3-provider-engine/subproviders/hooked-wallet';\nimport SubscriptionSubprovider from 'web3-provider-engine/subproviders/subscriptions';\nimport FilterSubprovider from 'web3-provider-engine/subproviders/filters';\n\nfunction createProvider(config) {\n  var getAccounts = config.getAccounts,\n      signTransaction = config.signTransaction,\n      rpcUrl = config.rpcUrl;\n  var idMgmt = new HookedWalletSubprovider({\n    getAccounts: getAccounts,\n    signTransaction: signTransaction\n  });\n  var rpcSubProvider = new RpcSource({\n    rpcUrl: rpcUrl.includes('http') ? rpcUrl : \"https://\".concat(rpcUrl)\n  });\n  var provider = new Web3ProviderEngine();\n  provider.addProvider(new SubscriptionSubprovider());\n  provider.addProvider(new FilterSubprovider());\n  provider.addProvider(idMgmt);\n  provider.addProvider(rpcSubProvider);\n  provider.start();\n  return provider;\n}\n\nexport { createProvider as c };","//@flow\n\nimport { sign, isSupported } from \"u2f-api\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportError } from \"@ledgerhq/errors\";\n\nfunction wrapU2FTransportError(originalError, message, id) {\n  const err = new TransportError(message, id);\n  // $FlowFixMe\n  err.originalError = originalError;\n  return err;\n}\n\nfunction wrapApdu(apdu: Buffer, key: Buffer) {\n  const result = Buffer.alloc(apdu.length);\n  for (let i = 0; i < apdu.length; i++) {\n    result[i] = apdu[i] ^ key[i % key.length];\n  }\n  return result;\n}\n\n// Convert from normal to web-safe, strip trailing \"=\"s\nconst webSafe64 = (base64: string) =>\n  base64\n    .replace(/\\+/g, \"-\")\n    .replace(/\\//g, \"_\")\n    .replace(/=+$/, \"\");\n\n// Convert from web-safe to normal, add trailing \"=\"s\nconst normal64 = (base64: string) =>\n  base64.replace(/-/g, \"+\").replace(/_/g, \"/\") +\n  \"==\".substring(0, (3 * base64.length) % 4);\n\nfunction attemptExchange(\n  apdu: Buffer,\n  timeoutMillis: number,\n  scrambleKey: Buffer,\n  unwrap: boolean\n): Promise<Buffer> {\n  const keyHandle = wrapApdu(apdu, scrambleKey);\n  const challenge = Buffer.from(\n    \"0000000000000000000000000000000000000000000000000000000000000000\",\n    \"hex\"\n  );\n  const signRequest = {\n    version: \"U2F_V2\",\n    keyHandle: webSafe64(keyHandle.toString(\"base64\")),\n    challenge: webSafe64(challenge.toString(\"base64\")),\n    appId: location.origin\n  };\n  log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n  return sign(signRequest, timeoutMillis / 1000).then(response => {\n    const { signatureData } = response;\n    if (typeof signatureData === \"string\") {\n      const data = Buffer.from(normal64(signatureData), \"base64\");\n      let result;\n      if (!unwrap) {\n        result = data;\n      } else {\n        result = data.slice(5);\n      }\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    } else {\n      throw response;\n    }\n  });\n}\n\nlet transportInstances = [];\n\nfunction emitDisconnect() {\n  transportInstances.forEach(t => t.emit(\"disconnect\"));\n  transportInstances = [];\n}\n\nfunction isTimeoutU2FError(u2fError) {\n  return u2fError.metaData.code === 5;\n}\n\n/**\n * U2F web Transport implementation\n * @example\n * import TransportU2F from \"@ledgerhq/hw-transport-u2f\";\n * ...\n * TransportU2F.create().then(transport => ...)\n */\nexport default class TransportU2F extends Transport<null> {\n  static isSupported = isSupported;\n\n  /*\n   */\n  static list = (): * =>\n    // this transport is not discoverable but we are going to guess if it is here with isSupported()\n    isSupported().then(supported => (supported ? [null] : []));\n\n  /*\n   */\n  static listen = (observer: *) => {\n    let unsubscribed = false;\n    isSupported().then(supported => {\n      if (unsubscribed) return;\n      if (supported) {\n        observer.next({ type: \"add\", descriptor: null });\n        observer.complete();\n      } else {\n        observer.error(\n          new TransportError(\n            \"U2F browser support is needed for Ledger. \" +\n              \"Please use Chrome, Opera or Firefox with a U2F extension. \" +\n              \"Also make sure you're on an HTTPS connection\",\n            \"U2FNotSupported\"\n          )\n        );\n      }\n    });\n    return {\n      unsubscribe: () => {\n        unsubscribed = true;\n      }\n    };\n  };\n\n  scrambleKey: Buffer;\n\n  unwrap: boolean = true;\n\n  /**\n   * static function to create a new Transport from a connected Ledger device discoverable via U2F (browser support)\n   */\n  static async open(_: *, _openTimeout?: number = 5000): Promise<TransportU2F> {\n    return new TransportU2F();\n  }\n\n  constructor() {\n    super();\n    transportInstances.push(this);\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  async exchange(apdu: Buffer): Promise<Buffer> {\n    try {\n      return await attemptExchange(\n        apdu,\n        this.exchangeTimeout,\n        this.scrambleKey,\n        this.unwrap\n      );\n    } catch (e) {\n      const isU2FError = typeof e.metaData === \"object\";\n      if (isU2FError) {\n        if (isTimeoutU2FError(e)) {\n          emitDisconnect();\n        }\n        // the wrapping make error more usable and \"printable\" to the end user.\n        throw wrapU2FTransportError(\n          e,\n          \"Failed to sign with Ledger device: U2F \" + e.metaData.type,\n          \"U2F_\" + e.metaData.code\n        );\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   */\n  setScrambleKey(scrambleKey: string) {\n    this.scrambleKey = Buffer.from(scrambleKey, \"ascii\");\n  }\n\n  /**\n   */\n  setUnwrap(unwrap: boolean) {\n    this.unwrap = unwrap;\n  }\n\n  close(): Promise<void> {\n    // u2f have no way to clean things up\n    return Promise.resolve();\n  }\n}\n","'use strict';\nmodule.exports = require( './lib/u2f-api' );","'use strict';\n\nmodule.exports = API;\n\nvar chromeApi = require( './google-u2f-api' );\n\n// Feature detection (yes really)\nvar isBrowser = ( typeof navigator !== 'undefined' ) && !!navigator.userAgent;\nvar isSafari = isBrowser && navigator.userAgent.match( /Safari\\// )\n\t&& !navigator.userAgent.match( /Chrome\\// );\nvar isEDGE = isBrowser && navigator.userAgent.match( /Edge\\/1[2345]/ );\n\nvar _backend = null;\nfunction getBackend( Promise )\n{\n\tif ( !_backend )\n\t\t_backend = new Promise( function( resolve, reject )\n\t\t{\n\t\t\tfunction notSupported( )\n\t\t\t{\n\t\t\t\t// Note; {native: true} means *not* using Google's hack\n\t\t\t\tresolve( { u2f: null, native: true } );\n\t\t\t}\n\n\t\t\tif ( !isBrowser )\n\t\t\t\treturn notSupported( );\n\n\t\t\tif ( isSafari )\n\t\t\t\t// Safari doesn't support U2F, and the Safari-FIDO-U2F\n\t\t\t\t// extension lacks full support (Multi-facet apps), so we\n\t\t\t\t// block it until proper support.\n\t\t\t\treturn notSupported( );\n\n\t\t\tvar hasNativeSupport =\n\t\t\t\t( typeof window.u2f !== 'undefined' ) &&\n\t\t\t\t( typeof window.u2f.sign === 'function' );\n\n\t\t\tif ( hasNativeSupport )\n\t\t\t\tresolve( { u2f: window.u2f, native: true } );\n\n\t\t\tif ( isEDGE )\n\t\t\t\t// We don't want to check for Google's extension hack on EDGE\n\t\t\t\t// as it'll cause trouble (popups, etc)\n\t\t\t\treturn notSupported( );\n\n\t\t\tif ( location.protocol === 'http:' )\n\t\t\t\t// U2F isn't supported over http, only https\n\t\t\t\treturn notSupported( );\n\n\t\t\tif ( typeof MessageChannel === 'undefined' )\n\t\t\t\t// Unsupported browser, the chrome hack would throw\n\t\t\t\treturn notSupported( );\n\n\t\t\t// Test for google extension support\n\t\t\tchromeApi.isSupported( function( ok )\n\t\t\t{\n\t\t\t\tif ( ok )\n\t\t\t\t\tresolve( { u2f: chromeApi, native: false } );\n\t\t\t\telse\n\t\t\t\t\tnotSupported( );\n\t\t\t} );\n\t\t} );\n\n\treturn _backend;\n}\n\nfunction API( Promise )\n{\n\treturn {\n\t\tisSupported   : isSupported.bind( Promise ),\n\t\tensureSupport : ensureSupport.bind( Promise ),\n\t\tregister      : register.bind( Promise ),\n\t\tsign          : sign.bind( Promise ),\n\t\tErrorCodes    : API.ErrorCodes,\n\t\tErrorNames    : API.ErrorNames\n\t};\n}\n\nAPI.ErrorCodes = {\n\tCANCELLED: -1,\n\tOK: 0,\n\tOTHER_ERROR: 1,\n\tBAD_REQUEST: 2,\n\tCONFIGURATION_UNSUPPORTED: 3,\n\tDEVICE_INELIGIBLE: 4,\n\tTIMEOUT: 5\n};\nAPI.ErrorNames = {\n\t\"-1\": \"CANCELLED\",\n\t\"0\": \"OK\",\n\t\"1\": \"OTHER_ERROR\",\n\t\"2\": \"BAD_REQUEST\",\n\t\"3\": \"CONFIGURATION_UNSUPPORTED\",\n\t\"4\": \"DEVICE_INELIGIBLE\",\n\t\"5\": \"TIMEOUT\"\n};\n\nfunction makeError( msg, err )\n{\n\tvar code = err != null ? err.errorCode : 1; // Default to OTHER_ERROR\n\tvar type = API.ErrorNames[ '' + code ];\n\tvar error = new Error( msg );\n\terror.metaData = {\n\t\ttype: type,\n\t\tcode: code\n\t}\n\treturn error;\n}\n\nfunction deferPromise( Promise, promise )\n{\n\tvar ret = { };\n\tret.promise = new Promise( function( resolve, reject ) {\n\t\tret.resolve = resolve;\n\t\tret.reject = reject;\n\t\tpromise.then( resolve, reject );\n\t} );\n\t/**\n\t * Reject request promise and disconnect port if 'disconnect' flag is true\n\t * @param {string} msg\n\t * @param {boolean} disconnect\n\t */\n\tret.promise.cancel = function( msg, disconnect )\n\t{\n\t\tgetBackend( Promise )\n\t\t.then( function( backend )\n\t\t{\n\t\t\tif ( disconnect && !backend.native )\n\t\t\t\tbackend.u2f.disconnect( );\n\n\t\t\tret.reject( makeError( msg, { errorCode: -1 } ) );\n\t\t} );\n\t};\n\treturn ret;\n}\n\nfunction defer( Promise, fun )\n{\n\treturn deferPromise( Promise, new Promise( function( resolve, reject )\n\t{\n\t\ttry\n\t\t{\n\t\t\tfun && fun( resolve, reject );\n\t\t}\n\t\tcatch ( err )\n\t\t{\n\t\t\treject( err );\n\t\t}\n\t} ) );\n}\n\nfunction isSupported( )\n{\n\tvar Promise = this;\n\n\treturn getBackend( Promise )\n\t.then( function( backend )\n\t{\n\t\treturn !!backend.u2f;\n\t} );\n}\n\nfunction _ensureSupport( backend )\n{\n\tif ( !backend.u2f )\n\t{\n\t\tif ( location.protocol === 'http:' )\n\t\t\tthrow new Error( \"U2F isn't supported over http, only https\" );\n\t\tthrow new Error( \"U2F not supported\" );\n\t}\n}\n\nfunction ensureSupport( )\n{\n\tvar Promise = this;\n\n\treturn getBackend( Promise )\n\t.then( _ensureSupport );\n}\n\nfunction register( registerRequests, signRequests /* = null */, timeout )\n{\n\tvar Promise = this;\n\n\tif ( !Array.isArray( registerRequests ) )\n\t\tregisterRequests = [ registerRequests ];\n\n\tif ( typeof signRequests === 'number' && typeof timeout === 'undefined' )\n\t{\n\t\ttimeout = signRequests;\n\t\tsignRequests = null;\n\t}\n\n\tif ( !signRequests )\n\t\tsignRequests = [ ];\n\n\treturn deferPromise( Promise, getBackend( Promise )\n\t.then( function( backend )\n\t{\n\t\t_ensureSupport( backend );\n\n\t\tvar native = backend.native;\n\t\tvar u2f = backend.u2f;\n\n\t\treturn new Promise( function( resolve, reject )\n\t\t{\n\t\t\tfunction cbNative( response )\n\t\t\t{\n\t\t\t\tif ( response.errorCode )\n\t\t\t\t\treject( makeError( \"Registration failed\", response ) );\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdelete response.errorCode;\n\t\t\t\t\tresolve( response );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction cbChrome( err, response )\n\t\t\t{\n\t\t\t\tif ( err )\n\t\t\t\t\treject( err );\n\t\t\t\telse if ( response.errorCode )\n\t\t\t\t\treject( makeError( \"Registration failed\", response ) );\n\t\t\t\telse\n\t\t\t\t\tresolve( response );\n\t\t\t}\n\n\t\t\tif ( native )\n\t\t\t{\n\t\t\t\tvar appId = registerRequests[ 0 ].appId;\n\n\t\t\t\tu2f.register(\n\t\t\t\t\tappId, registerRequests, signRequests, cbNative, timeout );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tu2f.register(\n\t\t\t\t\tregisterRequests, signRequests, cbChrome, timeout );\n\t\t\t}\n\t\t} );\n\t} ) ).promise;\n}\n\nfunction sign( signRequests, timeout )\n{\n\tvar Promise = this;\n\n\tif ( !Array.isArray( signRequests ) )\n\t\tsignRequests = [ signRequests ];\n\n\treturn deferPromise( Promise, getBackend( Promise )\n\t.then( function( backend )\n\t{\n\t\t_ensureSupport( backend );\n\n\t\tvar native = backend.native;\n\t\tvar u2f = backend.u2f;\n\n\t\treturn new Promise( function( resolve, reject )\n\t\t{\n\t\t\tfunction cbNative( response )\n\t\t\t{\n\t\t\t\tif ( response.errorCode )\n\t\t\t\t\treject( makeError( \"Sign failed\", response ) );\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdelete response.errorCode;\n\t\t\t\t\tresolve( response );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction cbChrome( err, response )\n\t\t\t{\n\t\t\t\tif ( err )\n\t\t\t\t\treject( err );\n\t\t\t\telse if ( response.errorCode )\n\t\t\t\t\treject( makeError( \"Sign failed\", response ) );\n\t\t\t\telse\n\t\t\t\t\tresolve( response );\n\t\t\t}\n\n\t\t\tif ( native )\n\t\t\t{\n\t\t\t\tvar appId = signRequests[ 0 ].appId;\n\t\t\t\tvar challenge = signRequests[ 0 ].challenge;\n\n\t\t\t\tu2f.sign( appId, challenge, signRequests, cbNative, timeout );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tu2f.sign( signRequests, cbChrome, timeout );\n\t\t\t}\n\t\t} );\n\t} ) ).promise;\n}\n\nfunction makeDefault( func )\n{\n\tAPI[ func ] = function( )\n\t{\n\t\tif ( !global.Promise )\n\t\t\t// This is very unlikely to ever happen, since browsers\n\t\t\t// supporting U2F will most likely support Promises.\n\t\t\tthrow new Error( \"The platform doesn't natively support promises\" );\n\n\t\tvar args = [ ].slice.call( arguments );\n\t\treturn API( global.Promise )[ func ].apply( null, args );\n\t};\n}\n\n// Provide default functions using the built-in Promise if available.\nmakeDefault( 'isSupported' );\nmakeDefault( 'ensureSupport' );\nmakeDefault( 'register' );\nmakeDefault( 'sign' );\n","// Copyright 2014 Google Inc. All rights reserved\n//\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file or at\n// https://developers.google.com/open-source/licenses/bsd\n\n/**\n * @fileoverview The U2F api.\n */\n\n'use strict';\n\n/** Namespace for the U2F api.\n * @type {Object}\n */\nvar u2f = u2f || {};\n\nmodule.exports = u2f; // Adaptation for u2f-api package\n\n/**\n * The U2F extension id\n * @type {string}\n * @const\n */\nu2f.EXTENSION_ID = 'kmendfapggjehodndflmmgagdbamhnfd';\n\n/**\n * Message types for messsages to/from the extension\n * @const\n * @enum {string}\n */\nu2f.MessageTypes = {\n  'U2F_REGISTER_REQUEST': 'u2f_register_request',\n  'U2F_SIGN_REQUEST': 'u2f_sign_request',\n  'U2F_REGISTER_RESPONSE': 'u2f_register_response',\n  'U2F_SIGN_RESPONSE': 'u2f_sign_response'\n};\n\n/**\n * Response status codes\n * @const\n * @enum {number}\n */\nu2f.ErrorCodes = {\n  'OK': 0,\n  'OTHER_ERROR': 1,\n  'BAD_REQUEST': 2,\n  'CONFIGURATION_UNSUPPORTED': 3,\n  'DEVICE_INELIGIBLE': 4,\n  'TIMEOUT': 5\n};\n\n/**\n * A message type for registration requests\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   signRequests: Array.<u2f.SignRequest>,\n *   registerRequests: ?Array.<u2f.RegisterRequest>,\n *   timeoutSeconds: ?number,\n *   requestId: ?number\n * }}\n */\nu2f.Request;\n\n/**\n * A message for registration responses\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   responseData: (u2f.Error | u2f.RegisterResponse | u2f.SignResponse),\n *   requestId: ?number\n * }}\n */\nu2f.Response;\n\n/**\n * An error object for responses\n * @typedef {{\n *   errorCode: u2f.ErrorCodes,\n *   errorMessage: ?string\n * }}\n */\nu2f.Error;\n\n/**\n * Data object for a single sign request.\n * @typedef {{\n *   version: string,\n *   challenge: string,\n *   keyHandle: string,\n *   appId: string\n * }}\n */\nu2f.SignRequest;\n\n/**\n * Data object for a sign response.\n * @typedef {{\n *   keyHandle: string,\n *   signatureData: string,\n *   clientData: string\n * }}\n */\nu2f.SignResponse;\n\n/**\n * Data object for a registration request.\n * @typedef {{\n *   version: string,\n *   challenge: string,\n *   appId: string\n * }}\n */\nu2f.RegisterRequest;\n\n/**\n * Data object for a registration response.\n * @typedef {{\n *   registrationData: string,\n *   clientData: string\n * }}\n */\nu2f.RegisterResponse;\n\n\n// Low level MessagePort API support\n\n/**\n * Call MessagePort disconnect\n */\nu2f.disconnect = function() {\n  if (u2f.port_ && u2f.port_.port_) {\n    u2f.port_.port_.disconnect();\n    u2f.port_ = null;\n  }\n};\n\n/**\n * Sets up a MessagePort to the U2F extension using the\n * available mechanisms.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n */\nu2f.getMessagePort = function(callback) {\n  if (typeof chrome != 'undefined' && chrome.runtime) {\n    // The actual message here does not matter, but we need to get a reply\n    // for the callback to run. Thus, send an empty signature request\n    // in order to get a failure response.\n    var msg = {\n      type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n      signRequests: []\n    };\n    chrome.runtime.sendMessage(u2f.EXTENSION_ID, msg, function() {\n      if (!chrome.runtime.lastError) {\n        // We are on a whitelisted origin and can talk directly\n        // with the extension.\n        u2f.getChromeRuntimePort_(callback);\n      } else {\n        // chrome.runtime was available, but we couldn't message\n        // the extension directly, use iframe\n        u2f.getIframePort_(callback);\n      }\n    });\n  } else {\n    // chrome.runtime was not available at all, which is normal\n    // when this origin doesn't have access to any extensions.\n    u2f.getIframePort_(callback);\n  }\n};\n\n/**\n * Connects directly to the extension via chrome.runtime.connect\n * @param {function(u2f.WrappedChromeRuntimePort_)} callback\n * @private\n */\nu2f.getChromeRuntimePort_ = function(callback) {\n  var port = chrome.runtime.connect(u2f.EXTENSION_ID,\n    {'includeTlsChannelId': true});\n  setTimeout(function() {\n    callback(null, new u2f.WrappedChromeRuntimePort_(port));\n  }, 0);\n};\n\n/**\n * A wrapper for chrome.runtime.Port that is compatible with MessagePort.\n * @param {Port} port\n * @constructor\n * @private\n */\nu2f.WrappedChromeRuntimePort_ = function(port) {\n  this.port_ = port;\n};\n\n/**\n * Posts a message on the underlying channel.\n * @param {Object} message\n */\nu2f.WrappedChromeRuntimePort_.prototype.postMessage = function(message) {\n  this.port_.postMessage(message);\n};\n\n/**\n * Emulates the HTML 5 addEventListener interface. Works only for the\n * onmessage event, which is hooked up to the chrome.runtime.Port.onMessage.\n * @param {string} eventName\n * @param {function({data: Object})} handler\n */\nu2f.WrappedChromeRuntimePort_.prototype.addEventListener =\n    function(eventName, handler) {\n  var name = eventName.toLowerCase();\n  if (name == 'message' || name == 'onmessage') {\n    this.port_.onMessage.addListener(function(message) {\n      // Emulate a minimal MessageEvent object\n      handler({'data': message});\n    });\n  } else {\n    console.error('WrappedChromeRuntimePort only supports onMessage');\n  }\n};\n\n/**\n * Sets up an embedded trampoline iframe, sourced from the extension.\n * @param {function(MessagePort)} callback\n * @private\n */\nu2f.getIframePort_ = function(callback) {\n  // Create the iframe\n  var iframeOrigin = 'chrome-extension://' + u2f.EXTENSION_ID;\n  var iframe = document.createElement('iframe');\n  iframe.src = iframeOrigin + '/u2f-comms.html';\n  iframe.setAttribute('style', 'display:none');\n  document.body.appendChild(iframe);\n\n  var hasCalledBack = false;\n\n  var channel = new MessageChannel();\n  var ready = function(message) {\n    if (message.data == 'ready') {\n      channel.port1.removeEventListener('message', ready);\n      if (!hasCalledBack)\n      {\n        hasCalledBack = true;\n        callback(null, channel.port1);\n      }\n    } else {\n      console.error('First event on iframe port was not \"ready\"');\n    }\n  };\n  channel.port1.addEventListener('message', ready);\n  channel.port1.start();\n\n  iframe.addEventListener('load', function() {\n    // Deliver the port to the iframe and initialize\n    iframe.contentWindow.postMessage('init', iframeOrigin, [channel.port2]);\n  });\n\n  // Give this 200ms to initialize, after that, we treat this method as failed\n  setTimeout(function() {\n    if (!hasCalledBack)\n    {\n      hasCalledBack = true;\n      callback(new Error(\"IFrame extension not supported\"));\n    }\n  }, 200);\n};\n\n\n// High-level JS API\n\n/**\n * Default extension response timeout in seconds.\n * @const\n */\nu2f.EXTENSION_TIMEOUT_SEC = 30;\n\n/**\n * A singleton instance for a MessagePort to the extension.\n * @type {MessagePort|u2f.WrappedChromeRuntimePort_}\n * @private\n */\nu2f.port_ = null;\n\n/**\n * Callbacks waiting for a port\n * @type {Array.<function((MessagePort|u2f.WrappedChromeRuntimePort_))>}\n * @private\n */\nu2f.waitingForPort_ = [];\n\n/**\n * A counter for requestIds.\n * @type {number}\n * @private\n */\nu2f.reqCounter_ = 0;\n\n/**\n * A map from requestIds to client callbacks\n * @type {Object.<number,(function((u2f.Error|u2f.RegisterResponse))\n *                       |function((u2f.Error|u2f.SignResponse)))>}\n * @private\n */\nu2f.callbackMap_ = {};\n\n/**\n * Creates or retrieves the MessagePort singleton to use.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n * @private\n */\nu2f.getPortSingleton_ = function(callback) {\n  if (u2f.port_) {\n    callback(null, u2f.port_);\n  } else {\n    if (u2f.waitingForPort_.length == 0) {\n      u2f.getMessagePort(function(err, port) {\n        if (!err) {\n          u2f.port_ = port;\n          u2f.port_.addEventListener('message',\n            /** @type {function(Event)} */ (u2f.responseHandler_));\n        }\n\n        // Careful, here be async callbacks. Maybe.\n        while (u2f.waitingForPort_.length)\n          u2f.waitingForPort_.shift()(err, port);\n      });\n    }\n    u2f.waitingForPort_.push(callback);\n  }\n};\n\n/**\n * Handles response messages from the extension.\n * @param {MessageEvent.<u2f.Response>} message\n * @private\n */\nu2f.responseHandler_ = function(message) {\n  var response = message.data;\n  var reqId = response['requestId'];\n  if (!reqId || !u2f.callbackMap_[reqId]) {\n    console.error('Unknown or missing requestId in response.');\n    return;\n  }\n  var cb = u2f.callbackMap_[reqId];\n  delete u2f.callbackMap_[reqId];\n  cb(null, response['responseData']);\n};\n\n/**\n * Calls the callback with true or false as first and only argument\n * @param {Function} callback\n */\nu2f.isSupported = function(callback) {\n  u2f.getPortSingleton_(function(err, port) {\n    callback(!err);\n  });\n}\n\n/**\n * Dispatches an array of sign requests to available U2F tokens.\n * @param {Array.<u2f.SignRequest>} signRequests\n * @param {function((u2f.Error|u2f.SignResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.sign = function(signRequests, callback, opt_timeoutSeconds) {\n  u2f.getPortSingleton_(function(err, port) {\n    if (err)\n      return callback(err);\n\n    var reqId = ++u2f.reqCounter_;\n    u2f.callbackMap_[reqId] = callback;\n    var req = {\n      type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n      signRequests: signRequests,\n      timeoutSeconds: (typeof opt_timeoutSeconds !== 'undefined' ?\n        opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC),\n      requestId: reqId\n    };\n    port.postMessage(req);\n  });\n};\n\n/**\n * Dispatches register requests to available U2F tokens. An array of sign\n * requests identifies already registered tokens.\n * @param {Array.<u2f.RegisterRequest>} registerRequests\n * @param {Array.<u2f.SignRequest>} signRequests\n * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.register = function(registerRequests, signRequests,\n    callback, opt_timeoutSeconds) {\n  u2f.getPortSingleton_(function(err, port) {\n    if (err)\n      return callback(err);\n\n    var reqId = ++u2f.reqCounter_;\n    u2f.callbackMap_[reqId] = callback;\n    var req = {\n      type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n      signRequests: signRequests,\n      registerRequests: registerRequests,\n      timeoutSeconds: (typeof opt_timeoutSeconds !== 'undefined' ?\n        opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC),\n      requestId: reqId\n    };\n    port.postMessage(req);\n  });\n};\n","//@flow\n\nimport EventEmitter from \"events\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport {\n  TransportRaceCondition,\n  TransportError,\n  StatusCodes,\n  getAltStatusMessage,\n  TransportStatusError\n} from \"@ledgerhq/errors\";\n\nexport {\n  TransportError,\n  TransportStatusError,\n  StatusCodes,\n  getAltStatusMessage\n};\n\n/**\n */\nexport type Subscription = { unsubscribe: () => void };\n\n/**\n */\nexport type Device = Object;\n\n/**\n * type: add or remove event\n * descriptor: a parameter that can be passed to open(descriptor)\n * deviceModel: device info on the model (is it a nano s, nano x, ...)\n * device: transport specific device info\n */\nexport type DescriptorEvent<Descriptor> = {\n  type: \"add\" | \"remove\",\n  descriptor: Descriptor,\n  deviceModel?: ?DeviceModel,\n  device?: Device\n};\n/**\n */\nexport type Observer<Ev> = $ReadOnly<{\n  next: (event: Ev) => mixed,\n  error: (e: any) => mixed,\n  complete: () => mixed\n}>;\n\n/**\n * Transport defines the generic interface to share between node/u2f impl\n * A **Descriptor** is a parametric type that is up to be determined for the implementation.\n * it can be for instance an ID, an file path, a URL,...\n */\nexport default class Transport<Descriptor> {\n  exchangeTimeout: number = 30000;\n  unresponsiveTimeout: number = 15000;\n\n  /**\n   * Statically check if a transport is supported on the user's platform/browser.\n   */\n  static +isSupported: () => Promise<boolean>;\n\n  /**\n   * List once all available descriptors. For a better granularity, checkout `listen()`.\n   * @return a promise of descriptors\n   * @example\n   * TransportFoo.list().then(descriptors => ...)\n   */\n  static +list: () => Promise<Array<Descriptor>>;\n\n  /**\n   * Listen all device events for a given Transport. The method takes an Obverver of DescriptorEvent and returns a Subscription (according to Observable paradigm https://github.com/tc39/proposal-observable )\n   * a DescriptorEvent is a `{ descriptor, type }` object. type can be `\"add\"` or `\"remove\"` and descriptor is a value you can pass to `open(descriptor)`.\n   * each listen() call will first emit all potential device already connected and then will emit events can come over times,\n   * for instance if you plug a USB device after listen() or a bluetooth device become discoverable.\n   * @param observer is an object with a next, error and complete function (compatible with observer pattern)\n   * @return a Subscription object on which you can `.unsubscribe()` to stop listening descriptors.\n   * @example\nconst sub = TransportFoo.listen({\n  next: e => {\n    if (e.type===\"add\") {\n      sub.unsubscribe();\n      const transport = await TransportFoo.open(e.descriptor);\n      ...\n    }\n  },\n  error: error => {},\n  complete: () => {}\n})\n   */\n  static +listen: (\n    observer: Observer<DescriptorEvent<Descriptor>>\n  ) => Subscription;\n\n  /**\n   * attempt to create a Transport instance with potentially a descriptor.\n   * @param descriptor: the descriptor to open the transport with.\n   * @param timeout: an optional timeout\n   * @return a Promise of Transport instance\n   * @example\nTransportFoo.open(descriptor).then(transport => ...)\n   */\n  static +open: (\n    descriptor: Descriptor,\n    timeout?: number\n  ) => Promise<Transport<Descriptor>>;\n\n  /**\n   * low level api to communicate with the device\n   * This method is for implementations to implement but should not be directly called.\n   * Instead, the recommanded way is to use send() method\n   * @param apdu the data to send\n   * @return a Promise of response data\n   */\n  exchange(_apdu: Buffer): Promise<Buffer> {\n    throw new Error(\"exchange not implemented\");\n  }\n\n  /**\n   * set the \"scramble key\" for the next exchanges with the device.\n   * Each App can have a different scramble key and they internally will set it at instanciation.\n   * @param key the scramble key\n   */\n  setScrambleKey(_key: string) {}\n\n  /**\n   * close the exchange with the device.\n   * @return a Promise that ends when the transport is closed.\n   */\n  close(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  _events = new EventEmitter();\n\n  /**\n   * Listen to an event on an instance of transport.\n   * Transport implementation can have specific events. Here is the common events:\n   * * `\"disconnect\"` : triggered if Transport is disconnected\n   */\n  on(eventName: string, cb: Function) {\n    this._events.on(eventName, cb);\n  }\n\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n  off(eventName: string, cb: Function) {\n    this._events.removeListener(eventName, cb);\n  }\n\n  emit(event: string, ...args: *) {\n    this._events.emit(event, ...args);\n  }\n\n  /**\n   * Enable or not logs of the binary exchange\n   */\n  setDebugMode() {\n    console.warn(\n      \"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\"\n    );\n  }\n\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n  setExchangeTimeout(exchangeTimeout: number) {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n\n  /**\n   * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n   */\n  setExchangeUnresponsiveTimeout(unresponsiveTimeout: number) {\n    this.unresponsiveTimeout = unresponsiveTimeout;\n  }\n\n  /**\n   * wrapper on top of exchange to simplify work of the implementation.\n   * @param cla\n   * @param ins\n   * @param p1\n   * @param p2\n   * @param data\n   * @param statusList is a list of accepted status code (shorts). [0x9000] by default\n   * @return a Promise of response buffer\n   */\n  send = async (\n    cla: number,\n    ins: number,\n    p1: number,\n    p2: number,\n    data: Buffer = Buffer.alloc(0),\n    statusList: Array<number> = [StatusCodes.OK]\n  ): Promise<Buffer> => {\n    if (data.length >= 256) {\n      throw new TransportError(\n        \"data.length exceed 256 bytes limit. Got: \" + data.length,\n        \"DataLengthTooBig\"\n      );\n    }\n    const response = await this.exchange(\n      Buffer.concat([\n        Buffer.from([cla, ins, p1, p2]),\n        Buffer.from([data.length]),\n        data\n      ])\n    );\n    const sw = response.readUInt16BE(response.length - 2);\n    if (!statusList.some(s => s === sw)) {\n      throw new TransportStatusError(sw);\n    }\n    return response;\n  };\n\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\nTransportFoo.create().then(transport => ...)\n   */\n  static create(\n    openTimeout?: number = 3000,\n    listenTimeout?: number\n  ): Promise<Transport<Descriptor>> {\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: e => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: e => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          if (!found) {\n            reject(\n              new TransportError(\n                this.ErrorMessage_NoDeviceFound,\n                \"NoDeviceFound\"\n              )\n            );\n          }\n        }\n      });\n      const listenTimeoutId = listenTimeout\n        ? setTimeout(() => {\n            sub.unsubscribe();\n            reject(\n              new TransportError(\n                this.ErrorMessage_ListenTimeout,\n                \"ListenTimeout\"\n              )\n            );\n          }, listenTimeout)\n        : null;\n    });\n  }\n\n  exchangeBusyPromise: ?Promise<void>;\n\n  // $FlowFixMe\n  exchangeAtomicImpl = async f => {\n    if (this.exchangeBusyPromise) {\n      throw new TransportRaceCondition(\n        \"An action was already pending on the Ledger device. Please deny or reconnect.\"\n      );\n    }\n    let resolveBusy;\n    const busyPromise = new Promise(r => {\n      resolveBusy = r;\n    });\n    this.exchangeBusyPromise = busyPromise;\n    let unresponsiveReached = false;\n    const timeout = setTimeout(() => {\n      unresponsiveReached = true;\n      this.emit(\"unresponsive\");\n    }, this.unresponsiveTimeout);\n    try {\n      const res = await f();\n      if (unresponsiveReached) {\n        this.emit(\"responsive\");\n      }\n      return res;\n    } finally {\n      clearTimeout(timeout);\n      if (resolveBusy) resolveBusy();\n      this.exchangeBusyPromise = null;\n    }\n  };\n\n  decorateAppAPIMethods(\n    self: Object,\n    methods: Array<string>,\n    scrambleKey: string\n  ) {\n    for (let methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(\n        methodName,\n        self[methodName],\n        self,\n        scrambleKey\n      );\n    }\n  }\n\n  _appAPIlock = null;\n  decorateAppAPIMethod<R, A: any[]>(\n    methodName: string,\n    f: (...args: A) => Promise<R>,\n    ctx: *,\n    scrambleKey: string\n  ): (...args: A) => Promise<R> {\n    return async (...args) => {\n      const { _appAPIlock } = this;\n      if (_appAPIlock) {\n        return Promise.reject(\n          new TransportError(\n            \"Ledger Device is busy (lock \" + _appAPIlock + \")\",\n            \"TransportLocked\"\n          )\n        );\n      }\n      try {\n        this._appAPIlock = methodName;\n        this.setScrambleKey(scrambleKey);\n        return await f.apply(ctx, args);\n      } finally {\n        this._appAPIlock = null;\n      }\n    };\n  }\n\n  static ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\n  static ErrorMessage_NoDeviceFound = \"No Ledger device found\";\n}\n","/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//@flow\n\n// FIXME drop:\nimport { splitPath, foreach } from \"./utils\";\nimport { EthAppPleaseEnableContractData } from \"@ledgerhq/errors\";\nimport type Transport from \"@ledgerhq/hw-transport\";\n\nconst remapTransactionRelatedErrors = e => {\n  if (e && e.statusCode === 0x6a80) {\n    return new EthAppPleaseEnableContractData(\n      \"Please enable Contract data on the Ethereum app Settings\"\n    );\n  }\n  return e;\n};\n\n/**\n * Ethereum API\n *\n * @example\n * import Eth from \"@ledgerhq/hw-app-eth\";\n * const eth = new Eth(transport)\n */\nexport default class Eth {\n  transport: Transport<*>;\n\n  constructor(transport: Transport<*>, scrambleKey: string = \"w0w\") {\n    this.transport = transport;\n    transport.decorateAppAPIMethods(\n      this,\n      [\n        \"getAddress\",\n        \"provideERC20TokenInformation\",\n        \"signTransaction\",\n        \"signPersonalMessage\",\n        \"getAppConfiguration\"\n      ],\n      scrambleKey\n    );\n  }\n\n  /**\n   * get Ethereum address for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @option boolChaincode optionally enable or not the chaincode request\n   * @return an object with a publicKey, address and (optionally) chainCode\n   * @example\n   * eth.getAddress(\"44'/60'/0'/0/0\").then(o => o.address)\n   */\n  getAddress(\n    path: string,\n    boolDisplay?: boolean,\n    boolChaincode?: boolean\n  ): Promise<{\n    publicKey: string,\n    address: string,\n    chainCode?: string\n  }> {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(\n        0xe0,\n        0x02,\n        boolDisplay ? 0x01 : 0x00,\n        boolChaincode ? 0x01 : 0x00,\n        buffer\n      )\n      .then(response => {\n        let result = {};\n        let publicKeyLength = response[0];\n        let addressLength = response[1 + publicKeyLength];\n        result.publicKey = response\n          .slice(1, 1 + publicKeyLength)\n          .toString(\"hex\");\n        result.address =\n          \"0x\" +\n          response\n            .slice(\n              1 + publicKeyLength + 1,\n              1 + publicKeyLength + 1 + addressLength\n            )\n            .toString(\"ascii\");\n        if (boolChaincode) {\n          result.chainCode = response\n            .slice(\n              1 + publicKeyLength + 1 + addressLength,\n              1 + publicKeyLength + 1 + addressLength + 32\n            )\n            .toString(\"hex\");\n        }\n        return result;\n      });\n  }\n\n  /**\n   * This commands provides a trusted description of an ERC 20 token\n   * to associate a contract address with a ticker and number of decimals.\n   *\n   * It shall be run immediately before performing a transaction involving a contract\n   * calling this contract address to display the proper token information to the user if necessary.\n   *\n   * @param {*} info: a blob from \"erc20.js\" utilities that contains all token information.\n   *\n   * @example\n   * import { byContractAddress } from \"@ledgerhq/hw-app-eth/erc20\"\n   * const zrxInfo = byContractAddress(\"0xe41d2489571d322189246dafa5ebde1f4699f498\")\n   * if (zrxInfo) await appEth.provideERC20TokenInformation(zrxInfo)\n   * const signed = await appEth.signTransaction(path, rawTxHex)\n   */\n  provideERC20TokenInformation({ data }: { data: Buffer }): Promise<boolean> {\n    return this.transport.send(0xe0, 0x0a, 0x00, 0x00, data).then(\n      () => true,\n      e => {\n        if (e && e.statusCode === 0x6d00) {\n          // this case happen for older version of ETH app, since older app version had the ERC20 data hardcoded, it's fine to assume it worked.\n          // we return a flag to know if the call was effective or not\n          return false;\n        }\n        throw e;\n      }\n    );\n  }\n\n  /**\n   * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign\n   * @example\n   eth.signTransaction(\"44'/60'/0'/0/0\", \"e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080\").then(result => ...)\n   */\n  signTransaction(\n    path: string,\n    rawTxHex: string\n  ): Promise<{\n    s: string,\n    v: string,\n    r: string\n  }> {\n    let paths = splitPath(path);\n    let offset = 0;\n    let rawTx = Buffer.from(rawTxHex, \"hex\");\n    let toSend = [];\n    let response;\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > rawTx.length\n          ? rawTx.length - offset\n          : maxChunkSize;\n      let buffer = Buffer.alloc(\n        offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, 0x00, data)\n        .then(apduResponse => {\n          response = apduResponse;\n        })\n    ).then(\n      () => {\n        const v = response.slice(0, 1).toString(\"hex\");\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { v, r, s };\n      },\n      e => {\n        throw remapTransactionRelatedErrors(e);\n      }\n    );\n  }\n\n  /**\n   */\n  getAppConfiguration(): Promise<{\n    arbitraryDataEnabled: number,\n    version: string\n  }> {\n    return this.transport.send(0xe0, 0x06, 0x00, 0x00).then(response => {\n      let result = {};\n      result.arbitraryDataEnabled = response[0] & 0x01;\n      result.version = \"\" + response[1] + \".\" + response[2] + \".\" + response[3];\n      return result;\n    });\n  }\n\n  /**\n  * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n  * @example\neth.signPersonalMessage(\"44'/60'/0'/0/0\", Buffer.from(\"test\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n})\n   */\n  signPersonalMessage(\n    path: string,\n    messageHex: string\n  ): Promise<{\n    v: number,\n    s: string,\n    r: string\n  }> {\n    let paths = splitPath(path);\n    let offset = 0;\n    let message = Buffer.from(messageHex, \"hex\");\n    let toSend = [];\n    let response;\n    while (offset !== message.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > message.length\n          ? message.length - offset\n          : maxChunkSize;\n      let buffer = Buffer.alloc(\n        offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);\n        message.copy(\n          buffer,\n          1 + 4 * paths.length + 4,\n          offset,\n          offset + chunkSize\n        );\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x08, i === 0 ? 0x00 : 0x80, 0x00, data)\n        .then(apduResponse => {\n          response = apduResponse;\n        })\n    ).then(() => {\n      const v = response[0];\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return { v, r, s };\n    });\n  }\n}\n","/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//@flow\n\ntype Defer<T> = {\n  promise: Promise<T>,\n  resolve: T => void,\n  reject: any => void\n};\n\nexport function defer<T>(): Defer<T> {\n  let resolve, reject;\n  let promise = new Promise(function(success, failure) {\n    resolve = success;\n    reject = failure;\n  });\n  if (!resolve || !reject) throw \"defer() error\"; // this never happens and is just to make flow happy\n  return { promise, resolve, reject };\n}\n\n// TODO use bip32-path library\nexport function splitPath(path: string): number[] {\n  let result = [];\n  let components = path.split(\"/\");\n  components.forEach(element => {\n    let number = parseInt(element, 10);\n    if (isNaN(number)) {\n      return; // FIXME shouldn't it throws instead?\n    }\n    if (element.length > 1 && element[element.length - 1] === \"'\") {\n      number += 0x80000000;\n    }\n    result.push(number);\n  });\n  return result;\n}\n\n// TODO use async await\n\nexport function eachSeries<A>(arr: A[], fun: A => Promise<*>): Promise<*> {\n  return arr.reduce((p, e) => p.then(() => fun(e)), Promise.resolve());\n}\n\nexport function foreach<T, A>(\n  arr: T[],\n  callback: (T, number) => Promise<A>\n): Promise<A[]> {\n  function iterate(index, array, result) {\n    if (index >= array.length) {\n      return result;\n    } else\n      return callback(array[index], index).then(function(res) {\n        result.push(res);\n        return iterate(index + 1, array, result);\n      });\n  }\n  return Promise.resolve().then(() => iterate(0, arr, []));\n}\n\nexport function doIf(\n  condition: boolean,\n  callback: () => any | Promise<any>\n): Promise<void> {\n  return Promise.resolve().then(() => {\n    if (condition) {\n      return callback();\n    }\n  });\n}\n\nexport function asyncWhile<T>(\n  predicate: () => boolean,\n  callback: () => Promise<T>\n): Promise<Array<T>> {\n  function iterate(result) {\n    if (!predicate()) {\n      return result;\n    } else {\n      return callback().then(res => {\n        result.push(res);\n        return iterate(result);\n      });\n    }\n  }\n  return Promise.resolve([]).then(iterate);\n}\n"],"sourceRoot":""}